\section{Linear Programming}
\label{sec:linear-programming}

In this part of the project the problem is solved using the Linear Programming
paradigm. In particular, we used the library CPLEX for C++ (version 12.7)
(see \cite{CplexWEB}) in order to implement the mathematical model that models
the problem and helps us solve it without having to implement our own algorithm.

\hfill

The use of this paradigm has its advantages and disadvantages.
One of the disadvantages is that it is not as expressive as the constraint
programming paradigm. For example, it does not easily allow logical expressions,
since they are not linear expressions. For example, in order to implement the
logical or ($a \vee b$) we have to introduce some new variables to help the
solver satisfy one of the two conditions.

\lluis{Give example for OR expression}
\lluis{Give example for AND expression}
\lluis{How to implement an implication?}

\lluis{Advantages: it allows easy optimisation}

\hfill

In spite of this, we do not to reformulate the constraints epxlained in
section \ref{sec:modelling} because CPLEX does the necessary transformations
seamlessly.

\lluis{After writing how are the constraints implemented, say that:
the constraint (3) in the simple solver is not needed, although without
it the solver assigns invalid values to the variables that model the cells
of each box.

\hfill

Look at commit\\
https://github.com/lluisalemanypuig/box-wrapping/commit/9a2c91a2fd8344e3e078649da105cd4d7227da71
}

\subsection{Implementation}
\label{sec:linear-programming:implementation}

In order to implement the variables detailed in section \ref{sec:modelling:variables},
three arrays of integer variables were used, each of them containing the variables described
in items \ref{var:box-cell}, \ref{var:box-corner} and \ref{var:box-rotated}. Taking
$L$ as the upper bound on the roll's length calculated with equation (\ref{eq:upper-bound-L}),
the arrays are initialised as follows:

\begin{enumerate}
	\item Array for variables in \ref{var:box-cell}:
    
	{\NOINDENT \begin{lstlisting}
	box_cell = IloNumVarArray(env, N*W*L, 0, 1, ILOINT);
	\end{lstlisting}}
    
	\item Array for variables in \ref{var:box-corner}:
    
	{\NOINDENT \begin{lstlisting}
	box_corner = IloNumVarArray(env, N*W*L, 0, 1, ILOINT);
	\end{lstlisting}}
    
	\item Array for variables in \ref{var:box-rotated}:
    
	{\NOINDENT \begin{lstlisting}
	box_rotated = IloNumVarArray(env, N, 0, 1, ILOINT);
	\end{lstlisting}}
    
\end{enumerate}

Following the CPLEX's requirements for a proper use of its solvers, we required the
use of these three objects:

{\NOINDENT \begin{lstlisting}
IloEnv env;
IloModel model(env);
IloCplex cplex(model);
\end{lstlisting}}

Assuming the implementation of the following functions to facilitate
access to the arrays of variables:

{\NOINDENT \begin{lstlisting}
inline IloNumVar X(size_t b, size_t x, size_t y) const { return box_corner[b*W*L + y*W + x]; }
inline IloNumVar C(size_t b, size_t x, size_t y) const { return box_cell[b*W*L + y*W + x]; }
inline IloNumVar R(size_t b) const { return box_rotated[b]; }

inline IloNumVar X(size_t b, size_t x, size_t y) { return box_corner[b*W*L + y*W + x]; }
inline IloNumVar C(size_t b, size_t x, size_t y) { return box_cell[b*W*L + y*W + x]; }
inline IloNumVar R(size_t b) { return box_rotated[b]; }
\end{lstlisting}}

the implementation of the constraints detailed in section \ref{sec:modelling:constraints}
using the CPLEX library is as follows:

\begin{enumerate}
	\item All boxes must be in the solution (constraint formalised in
	\ref{constr:box-placed}, equation \ref{eq:constraint:all-boxes-used}),
	also read as ``assign a top-left corner to each box''.
    
	{\NOINDENT \begin{lstlisting}
	for (int b = 0; b < N; ++b) {
		IloExpr exa_X(env);
		for (length i = 0; i < L; ++i) {
			for (width j = 0; j < W; ++j) {
				exa_X += X(b,i,j);
			}
		}
		model.add(exa_X == 1);
		exa_X.end();
	}
	\end{lstlisting}}
    
	\item Boxes cannot overlap (constraint formalised in
	\ref{constr:no-overlap}, constraint \ref{eq:constraint:one-box-cell}).
    
	{\NOINDENT \begin{lstlisting}
	for (length i = 0; i < L; ++i) {
		for (width j = 0; j < W; ++j) {
			IloExpr amo_C(env);
			for (int b = 0; b < N; ++b) {
				amo_C += C(b,i,j);
			}
			model.add(amo_C <= 1);
			amo_C.end();
		}
	}
	\end{lstlisting}}
    
	\item Depending on their rotation, boxes occupy certain cells of the roll
	(constraint formalised in \ref{constr:box-rot-span}). For those cells $(x,y)$ within
	bounds for $b$-th box:

	\begin{itemize}
		\item For square boxes (constraint \ref{eq:span-cells:square-boxes}):
		{\NOINDENT \begin{lstlisting}
		for (length i = y; i <= y + b_length - 1; ++i) {
			for (width j = x; j <= x + b_width - 1; ++j) {
				model.add(
					IloIfThen(env, (X(b,x,y) == 1), (C(b,j,i) == 1))
				);
			}
		}
		model.add(R(b) == 0);
		\end{lstlisting}}
		
		\item For rectangular boxes (constraints \ref{eq:span-cells:rectangular-boxes:0} and
		\ref{eq:span-cells:rectangular-boxes:1}):
		{\NOINDENT \begin{lstlisting}
		for (length i = y; i <= y + b_length - 1; ++i) {
			for (width j = x; j <= x + b_width - 1; ++j) {
				model.add(
					IloIfThen(env, ((R(b) == 0) && (X(b,x,y) == 1)), (C(b,j,i) == 1))
				);
			}
		}
		\end{lstlisting}}
		{\NOINDENT \begin{lstlisting}
		for (length i = y; i <= y + b_width - 1; ++i) {
			for (width j = x; j <= x + b_length - 1; ++j) {
				model.add(
					IloIfThen(env, ((R(b) == 1) && (X(b,x,y) == 1)), (C(b,j,i) == 1))
				);
			}
		}
		\end{lstlisting}}
	\end{itemize}
    
	\item Depending on their rotation, boxes cannot occupy certain cells of the
	roll (constraint formalised in \ref{constr:box-forbid}). For those cells $(x,y)$
	out of bounds for $b$-th box:
    
	\begin{itemize}
		\item For square boxes (constraint \ref{eq:forbid-span-cells:square-boxes}):
		{\NOINDENT \begin{lstlisting}
		model.add(X(b,x,y) == 0);
		\end{lstlisting}}
		
		\item For rectangular boxes (constraints \ref{eq:forbid-span-cells:rectangular-boxes:0}
		and \ref{eq:forbid-span-cells:rectangular-boxes:1}):
		{\NOINDENT \begin{lstlisting}
		model.add(
			IloIfThen(env, (R(b) == 0), (X(b,x,y) == 0))
		);
		\end{lstlisting}}
		{\NOINDENT \begin{lstlisting}
		model.add(
			IloIfThen(env, (R(b) == 1), (X(b,x,y) == 0))
		);
		\end{lstlisting}}
	\end{itemize}
    
\end{enumerate}

\subsection{Finding the optimium solution}
\label{sec:linear-programming:optimum}

\lluis{
Explain the new variables introduced and the objective function
}


