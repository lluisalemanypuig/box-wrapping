\section{Linear Programming}
\label{sec:linear-programming}

In this part of the project the problem is solved using the Linear Programming
paradigm. In particular, we used the library CPLEX for C++ (version 12.7)
(see \cite{CplexWEB}) in order to implement the mathematical model that models
the problem and helps us solve it without having to implement our own algorithm.

\hfill

The use of this paradigm has its advantages and disadvantages.
One of the the advantages is that we can naturally model optimisation problems
with their own objective function (whose value has to be maximised or minimised).
One of the disadvantages is that it is not as expressive as the constraint
programming paradigm. For example, it does not easily allow logical expressions,
since they are not linear. For example, in order to implement the
logical or ($a \vee b$, where $a$ and $b$ are linear expressions) we have to
introduce some new variables to help the solver satisfy one of the two conditions.
Now follows an explanation on how to transform several logical expressions into
linear expressions, assuming them to be integer-valued for all feasible solution,
using simple transformations that relate each expression to 0/1 variables. Let
$\delta_1$, $\delta_2$ be such variables:

\begin{itemize}	
	\item $(\delta_1 = 1) \vee (\delta_2 = 1)$. Impose $\delta_1 + \delta_2 \ge 1$.
	
	\item $(\delta_1 = 0) \vee (\delta_2 = 1)$.	Impose $\delta_1 \le \delta_2$.
	
	\item $(\delta_1 = 0) \vee (\delta_2 = 0)$.	Impose $\delta_1 + \delta_2 \le 1$.
	
	\item $(\delta_1 = 1) \wedge (\delta_2 = 1)$. Impose $\delta_1 + \delta_2 = 2$.
	
	\item $(\delta_1 = 0) \wedge (\delta_2 = 1)$. Impose $1 - \delta_1 + \delta_2 = 2$.	
	
	\item $(\delta_1 = 0) \wedge (\delta_2 = 0)$. Impose $\delta_1 + \delta_2 = 0$.
	
	\item $(\delta_1 = b_1) \Longrightarrow (\delta_2 = b_2) \equiv (\delta_1 = 1 - b_1) \vee (\delta_2 = b_2)$,
	for any two values $b_1,b_2 \in \mathbb{B}$.
	
	\item $(\delta_1 = b_1) \Longleftrightarrow (\delta_2 = b_2)$. Impose the two logical constraints
	$(\delta_1 = b_1) \Longrightarrow (\delta_2 = b_2)$ and $(\delta_2 = b_2) \Longrightarrow (\delta_1 = b_1)$,
	for any two values $b_1,b_2 \in \mathbb{B}$.
	
\end{itemize}

Relating linear expressions through logical operators is slightly more complicated.
In general, given two integer-valued linear expressions $a_1^Tx \le b_1$ and
$a_2^Tx \le b_2$ are for all feasible solution $x$, to model the logical expression
\[
(a_1^Tx \le b_1) \;\Box\; (a_2^Tx \le b_2)
\]
where $\Box$ is any binary logical operator $\vee,\wedge,\Longrightarrow,\Longleftrightarrow$,
we have to apply the following procedure: for each of the two linear expressions introduce a 0/1
variable. Let $\delta_1$ and $\delta_2$ be these variables defined so that:
\[
(\delta_1 = 1) \Longleftrightarrow (a_1^Tx \le b_1), \qquad 
(\delta_2 = 1) \Longleftrightarrow (a_2^Tx \le b_2)
\]
It only remains to impose the logical constraint $(\delta_1 = 1) \;\Box\; (\delta_2 = 1)$,
and use linear expressions for the two double implications:
\[
a_i^Tx - b_i \le \mathcal{U}_i(1 - \delta_i), \qquad a_i^Tx - b_i \ge (\mathcal{L}_i - 1)\delta_i + 1
\]
where $\mathcal{U}_i$ and $\mathcal{L}_i$ are upper and lower bounds, respectively, for
the expression $a_i^Tx - b_i$, for $i\in\{1,2\}$.

\hfill

In spite of logical constraints not being linear expressions, we do not need to reformulate
the constraints explained in section \ref{sec:modelling} because CPLEX does the necessary
transformations automatically.

\subsection{Implementation}
\label{sec:linear-programming:implementation}

In order to implement the variables detailed in section \ref{sec:modelling:variables},
three arrays of integer variables were used, each of them containing the variables described
in items \ref{var:box-cell}, \ref{var:box-corner} and \ref{var:box-rotated}. Taking
$L$ as the upper bound on the roll's length calculated with equation (\ref{eq:upper-bound-L}),
the arrays are initialised as follows:

\begin{enumerate}
	\item Array for variables in \ref{var:box-cell} ($C_{b,x,y}$):
    
	{\NOINDENT \begin{lstlisting}
	box_cell = IloNumVarArray(env, N*W*L, 0, 1, ILOINT);
	\end{lstlisting}}
    
	\item Array for variables in \ref{var:box-corner} ($X_{b,x,y}$):
    
	{\NOINDENT \begin{lstlisting}
	box_corner = IloNumVarArray(env, N*W*L, 0, 1, ILOINT);
	\end{lstlisting}}
    
	\item Array for variables in \ref{var:box-rotated} ($R_b$):
    
	{\NOINDENT \begin{lstlisting}
	box_rotated = IloNumVarArray(env, N, 0, 1, ILOINT);
	\end{lstlisting}}
    
\end{enumerate}

Following the CPLEX's requirements for a proper use of its solvers, we required the
use of these three objects:

{\NOINDENT \begin{lstlisting}
IloEnv env;
IloModel model(env);
IloCplex cplex(model);
\end{lstlisting}}

Assuming the implementation of the following functions to facilitate
access to the arrays of variables:

{\NOINDENT \begin{lstlisting}
// 0 <= b < N, 0 <= x < W, 0 <= y < L
inline IloNumVar X(size_t b, size_t x, size_t y) const { return box_corner[b*W*L + y*W + x]; }
inline IloNumVar C(size_t b, size_t x, size_t y) const { return box_cell[b*W*L + y*W + x]; }
inline IloNumVar R(size_t b) const { return box_rotated[b]; }

inline IloNumVar X(size_t b, size_t x, size_t y) { return box_corner[b*W*L + y*W + x]; }
inline IloNumVar C(size_t b, size_t x, size_t y) { return box_cell[b*W*L + y*W + x]; }
inline IloNumVar R(size_t b) { return box_rotated[b]; }
\end{lstlisting}}

the implementation of the constraints detailed in section \ref{sec:modelling:constraints}
using the CPLEX library is as follows:

\begin{enumerate}
	\item All boxes must be in the solution (constraint formalised in
	\ref{constr:box-placed}, equation \ref{eq:constraint:all-boxes-used}),
	also read as ``assign a top-left corner to each box''.
    
	{\NOINDENT \begin{lstlisting}
	for (int b = 0; b < N; ++b) {
		IloExpr exa_X(env);
		for (length y = 0; y < L; ++y) {
			for (width x = 0; x < W; ++x) {
				exa_X += X(b,y,x);
			}
		}
		model.add(exa_X == 1);
		exa_X.end();
	}
	\end{lstlisting}}
    
	\item Boxes cannot overlap (constraint formalised in
	\ref{constr:no-overlap}, constraint \ref{eq:constraint:one-box-cell}).
    
	{\NOINDENT \begin{lstlisting}
	for (length y = 0; y < L; ++y) {
		for (width x = 0; x < W; ++x) {
			IloExpr amo_C(env);
			for (int b = 0; b < N; ++b) {
				amo_C += C(b,x,y);
			}
			model.add(amo_C <= 1);
			amo_C.end();
		}
	}
	\end{lstlisting}}
    
	\item Depending on their rotation, boxes occupy certain cells of the roll
	(constraint formalised in \ref{constr:box-rot-span}). For those cells $(x,y)$ within
	bounds for $b$-th box:

	\begin{itemize}
		\item For square boxes (constraint \ref{eq:span-cells:square-boxes}):
		{\NOINDENT \begin{lstlisting}
		for (length i = y; i <= y + b_length - 1; ++i) {
			for (width j = x; j <= x + b_width - 1; ++j) {
				model.add(
					IloIfThen(env, (X(b,x,y) == 1), (C(b,j,i) == 1))
				);
			}
		}
		model.add(R(b) == 0);
		\end{lstlisting}}
		
		\item For rectangular boxes (constraints \ref{eq:span-cells:rectangular-boxes:0} and
		\ref{eq:span-cells:rectangular-boxes:1}):
		{\NOINDENT \begin{lstlisting}
		for (length i = y; ii <= y + b_length - 1; ++i) {
			for (width j = x; j <= x + b_width - 1; ++j) {
				model.add(
					IloIfThen(env, ((R(b) == 0) && (X(b,x,y) == 1)), (C(b,j,i) == 1))
				);
			}
		}
		\end{lstlisting}}
		{\NOINDENT \begin{lstlisting}
		for (length i = y; i <= y + b_width - 1; ++i) {
			for (width j = x; j <= x + b_length - 1; ++j) {
				model.add(
					IloIfThen(env, ((R(b) == 1) && (X(b,x,y) == 1)), (C(b,j,i) == 1))
				);
			}
		}
		\end{lstlisting}}
	\end{itemize}
    
	\item Depending on their rotation, boxes cannot occupy certain cells of the
	roll (constraint formalised in \ref{constr:box-forbid}). For those cells $(x,y)$
	out of bounds for $b$-th box:
    
	\begin{itemize}
		\item For square boxes (constraint \ref{eq:forbid-span-cells:square-boxes}):
		{\NOINDENT \begin{lstlisting}
		model.add(X(b,x,y) == 0);
		\end{lstlisting}}
		
		\item For rectangular boxes (constraints \ref{eq:forbid-span-cells:rectangular-boxes:0}
		and \ref{eq:forbid-span-cells:rectangular-boxes:1}):
		{\NOINDENT \begin{lstlisting}
		model.add(
			IloIfThen(env, (R(b) == 0), (X(b,x,y) == 0))
		);
		\end{lstlisting}}
		{\NOINDENT \begin{lstlisting}
		model.add(
			IloIfThen(env, (R(b) == 1), (X(b,x,y) == 0))
		);
		\end{lstlisting}}
	\end{itemize}
    
\end{enumerate}

The implementation for constraint \ref{eq:span-cells:square-boxes} using linear
expressions can be done in the following way. For non-square boxes, the constraints
are expressed as follows:
\[
(R_b = 0) \wedge (X_{b,x,y} = 1) \Longrightarrow (C_{b,j,i} = 1)
\]
This is clearly not a linear expression but it can be transformed into one by noticing
that the logical constraint is equivalent to
\[
(R_b = 1) \vee (X_{b,x,y} = 0) \vee (C_{b,j,i} = 1)
\]
From here we can obtain the linear expressions that model this logical constraint.
The transformation for this particular case is detailed in section
\ref{sec:conv-non-linear:3-ors}.

\subsubsection{Completing the model}
\label{sec:linear-programming:implementation:completion}

All the ``linear'' expressions above are the only required according to the
general modelling of the problem described in section \ref{sec:modelling}. However,
the linear programming paradigm requires an extra constraint: each box can not
occupy more cells than its area. This constraint is required for the following
reason: since is logically true that ``false implies true'' we can have many
cells $c$ of the roll assigned to some box $b$ even if its top-left corner is not
assigned to any cell $t$ nearby\footnote{By ``nearby'' we mean ``placed at a cell so that
according to the box's rotation and its dimensions cell $c$ falls within the
area that should be occupied by $b$ when its top-left corner is assigned to $t$.''}.
This way we may encounter an assignation that makes a box have, not only more cells
than it should, but also cells assigned throughout the roll completely scattered.
See figure \ref{fig:invalid-roll} for an illustration of this phenomenon.

\begin{figure}[H]
\centering
{\scriptsize
\begin{BVerbatim}
   | W              | W              | W              | W              | W           
 L |  0  1  2     L |  0  1  2     L |  0  1  2     L |  0  1  2     L |  0  1  2
-------------    -------------    -------------    -------------    -------------
 0 | 13 13 12    10 | 12 13  9    20 | 13 13 13    30 |  4  4  4    40 |  3 13 11 
 1 |  6  6 12    11 | 11 13  8    21 |  4 13 13    31 |  4  4  4    41 |  7  7  7 
 2 |  6  6 12    12 | 13 13 13    22 | 13 13 13    32 |  4  4  1    42 |  7  7 12 
 3 |  6  6 12    13 | 13  5  5    23 |  1 12 13    33 | 12  2  1    43 |  7  7 13 
 4 |  6  6 12    14 | 13  5  5    24 |  4  8 13    34 | 13  2  1    44 |  7  7 12 
 5 |  8  8 13    15 | 12  5  5    25 | 11  4 13    35 | 11  2 13    45 |  7 13 10 
 6 |  8  8 13    16 | 13  5  5    26 | 13  4 13    36 | 12 13 11 
 7 |  8  8 11    17 | 13 12 13    27 | 13 11 13    37 | 12 13 11 
 8 |  8  8 13    18 |  7 12 12    28 | 13 12  4    38 |  3 13 11 
 9 |  8  8 13    19 | 13 13 11    29 |  4  4 13    39 |  3 11 11 
\end{BVerbatim}
}
\centeredcaption{Invalid contents of the roll without rotations and optimisation for instance
\textit{instances/material/bwp\_3\_13\_1.in}}
\label{fig:invalid-roll}
\end{figure}

In spite of this, this only affects the extraction of the solution. Moreover, it 
is just a minor problem: the construction of the solution only requires knowing the
rotation and the position of the top-left corner of each box. Knowing these two,
and having access to the input data, we can easily construct the valid roll\footnote{The
actual solution to the problem, as specified in the statement, is not the roll
itself but only the top-left and bottom-right corners of each box.}
(see figure \ref{fig:valid-roll}). Therefore, the constraint is not only superfluous,
but also its implementation and addition to the model only slows down its performance.

\begin{figure}[H]
\centering
{\scriptsize
\begin{BVerbatim}
   | W            | W            | W            | W            | W    
 L | 0 1  2     L | 0 1  2     L | 0 1  2     L | 0 1  2     L | 0 1  2    
-----------    -----------    -----------    -----------    -----------
 0 | . . 12    10 | . .  9    20 | . .  .    30 | 4 4  .    40 | 3 . 11 
 1 | 6 6 12    11 | . .  .    21 | . .  .    31 | 4 4  .    41 | 7 7  . 
 2 | 6 6 12    12 | . .  .    22 | . . 13    32 | 4 4  1    42 | 7 7  . 
 3 | 6 6 12    13 | . 5  5    23 | . . 13    33 | . 2  1    43 | 7 7  . 
 4 | 6 6 12    14 | . 5  5    24 | . . 13    34 | . 2  1    44 | 7 7  . 
 5 | . .  .    15 | . 5  5    25 | . . 13    35 | . 2  .    45 | . . 10
 6 | 8 8  .    16 | . 5  5    26 | . . 13    36 | . . 11 
 7 | 8 8  .    17 | . .  .    27 | . .  .    37 | . . 11 
 8 | 8 8  .    18 | . .  .    28 | . .  .    38 | 3 . 11 
 9 | 8 8  .    19 | . .  .    29 | 4 4  .    39 | 3 . 11 
\end{BVerbatim}
}
\centeredcaption{Valid contents of the roll without rotations and optimisation for instance
\textit{instances/material/bwp\_3\_13\_1.in}}
\label{fig:valid-roll}
\end{figure}

\subsection{Finding the optimium solution}
\label{sec:linear-programming:optimum}

In the Linear Programming paradigm, the solver uses an objective function to find an optimal
solution. This objective function is simple: it suffices to minimise the maximum length
coordinate of roll used over all boxes' coordinate length $S_b$. A box's length coordinate
is simply the  coordinate of its bottom-left (or bottom-right) corner. Therefore, the
objective function can be formalised as
\begin{equation}
\label{eq:linear-programming:objective-func}
\min \max_{1 \le b \le N} S_b
\end{equation}

Although the $\max_b$ is not a linear function, CPLEX supports it perfectly. However, it has
been implemented using linear expressions due to its simplicity. For this, a new variable $M$
was introduced, defined so that $M \ge S_b$, for all $b \in \{1,\cdots,n\}$. Then, the objective
function is simply:
\[
\min M
\]

However, $S_b$ still needs to be defined. This is also rather simple. For each box $b$ and for
each cell of the roll $(x,y)$ impose the following two constraints:
\[
(R_b = 0) \wedge (X_{b,x,y} = 1) \Longrightarrow (S_b = y + b_l), \qquad
(R_b = 1) \wedge (X_{b,x,y} = 1) \Longrightarrow (S_b = y + b_w)
\]
This is implemented with the following piece of code:
{\NOINDENT \begin{lstlisting}
Sb = IloNumVarArray(env, N, 0, L, ILOINT);
M = IloNumVar(env, 0, L, ILOINT);
for (int b = 0; b < N; ++b) {
	for (length y = 0; y < L; ++y) {
		for (width x = 0; x < W; ++x) {
			model.add(
				IloIfThen(env, ((R(b) == 0) && (X(b,x,y) == 1)), (S(b) == y + b_length))
			);
			model.add(
				IloIfThen(env, ((R(b) == 1) && (X(b,x,y) == 1)), (S(b) == y + b_width))
			);
		}
	}
	model.add(M >= S(b));
}
model.add(
	IloMinimize(env, M)
);
\end{lstlisting}}
where the function ``S(b)'' is defined as follows
Assuming the definition of the two following functions:
{\NOINDENT \begin{lstlisting}
IloNumVar S(size_t b) const { return Sb[b]; }
IloNumVar S(size_t b) { return Sb[b]; }
\end{lstlisting}}

Despite the existence of an explicit objective function one could still perform
some basic transformations on the input data, similar to the ones described in
section \ref{sec:constraint-programming:optimum:heuristics}, hoping that it can
help the solver find better solutions faster. However, a few basic experiments
show that this is not the case. In fact, the short execution time the solver is
allowed\footnote{ Since we want to apply several heuristics, it is important not
to let the solver for too long, or it might take more than 120 seconds which the
time limit imposed in the statement.} does not let it find solutions that are
as good as the ones found when the solver is allowed to run for 45 seconds straight
without any kind of transformation.

\subsection{Compilation and execution}
\label{sec:linear-programming:compilation-execution}

In order to compile this part of the project, while assuming that we are at the
root directory of the project, one should issue the following commands:
\begin{lstlisting}[language=bash]
~/box-wrapping$ cd LP/build-rules
~/box-wrapping/LP/build-rules$ make -f Makefile release
~/box-wrapping/LP/build-rules$ cd ..
~/box-wrapping/LP$ cd build-release
\end{lstlisting}

However, the ``Makefile.ibm'' file in the \textit{build-rules/} directory may have
to be modified. In particular, the variables that contain the paths containing the
headers used in the include path for the compiler:
\begin{lstlisting}[language=bash]
SYSTEM		= x86-64_linux
LIB_FORMAT	= static_pic
CPLEX_DIR	= /opt/ibm/ILOG/CPLEX_Studio1271/cplex
CONCERT_DIR	= /opt/ibm/ILOG/CPLEX_Studio1271/concert
\end{lstlisting}

Once the compilation has finished we can execute the binary file generated\footnote{ There
is no need to create the directory \textit{build-release/} prior to compiling.}. The
complete usage can be seen by issuing the command:
\begin{lstlisting}[language=bash]
$ ./wrapping-boxes --help
\end{lstlisting}

The solver accepts few parameters. One of them is mandatory: the input file
containing the instance to be solved passed with ``-i''. The file to store
the output is optional and is passed with ``-o''. In order to obtain a solution
that minimises the roll length used, use ``--optim''. Two extra options can
be passed to affect the way the solver is executed: determine the number of
threads with ``--n-threads'' and use ``--stop-when'' to indicate a timeout.
An example can be seen in figure \ref{fig:linear-programming:example-usage}.

\begin{figure}[H]
\centering
\begin{lstlisting}[language=bash,basicstyle=\centering]
$ ./wrapping-boxes --optim -i bwp_3_3_1.in -o bwp_3_3_1.out --n-threads 8
\end{lstlisting}
\centeredcaption{An example of how to use the Linear Programming solver.}
\label{fig:linear-programming:example-usage}
\end{figure}





