\section{Constraint Programming}
\label{sec:constraint-programming}

In this part of the project the problem is solved using the Constraint Programming
paradigm. In particular, we used the library Gecode for C++ (version 6.0.0)
(see \cite{GecodeWEB}) in order to implement the mathematical model that models
the problem and helps us solve it without having to implement our own algorithm.

\subsection{Implementation}
\label{sec:constraint-programming:implementation}

In order to implement the variables detailed in section \ref{sec:modelling:variables}
three arrays of Boolean variables were used, each of them containing the variables described
in items \ref{var:box-cell}, \ref{var:box-corner} and \ref{var:box-rotated}. Taking
$L$ as the upper bound on the roll's length calculated with equation (\ref{eq:upper-bound-L}),
the arrays are initialised as follows:

\begin{enumerate}
	\item Array for variables in \ref{var:box-cell} ($C_{b,x,y}$):
    
	{\NOINDENT \begin{lstlisting}
	box_cell = BoolVarArray(*this, N*W*L, 0, 1);
	\end{lstlisting}}
    
	\item Array for variables in \ref{var:box-corner} ($X_{b,x,y}$):
    
	{\NOINDENT \begin{lstlisting}
	box_corner = BoolVarArray(*this, N*W*L, 0, 1);
	\end{lstlisting}}
    
	\item Array for variables in \ref{var:box-rotated} ($R_b$):
    
	{\NOINDENT \begin{lstlisting}
	box_rotated = BoolVarArray(*this, N, 0, 1);
	\end{lstlisting}}
    
\end{enumerate}

Assuming the implementation of the following functions to facilitate
access to the arrays of variables:

{\NOINDENT \begin{lstlisting}
// 0 <= b < N, 0 <= x < W, 0 <= y < L
inline BoolVar X(size_t b, size_t x, size_t y) const { return box_corner[b*W*L + y*W + x]; }
inline BoolVar C(size_t b, size_t x, size_t y) const { return box_cell[b*W*L + y*W + x]; }
inline BoolVar R(size_t b) const { return box_rotated[b]; }

inline BoolVar X(size_t b, size_t x, size_t y) { return box_corner[b*W*L + y*W + x]; }
inline BoolVar C(size_t b, size_t x, size_t y) { return box_cell[b*W*L + y*W + x]; }
inline BoolVar R(size_t b) { return box_rotated[b]; }
\end{lstlisting}}

the implementation of the constraints detailed in section \ref{sec:modelling:constraints}
using the Gecode library is as follows:

\begin{enumerate}
	\item All boxes must be in the solution (constraint formalised in
	\ref{constr:box-placed}), also read as ``all boxes must have assigned a top-left corner''.
    
	{\NOINDENT \begin{lstlisting}
	for (int b = 0; b < N; ++b) {
		rel(*this, sum(box_corner.slice(b*W*L, 1, W*L)) == 1);
	}
	\end{lstlisting}}
    
	\item Boxes cannot overlap (constraint formalised in \ref{constr:no-overlap}).
    
	{\NOINDENT \begin{lstlisting}
	for (int b = 0; b < N; ++b) {l
		for (length y = 0; y < L; ++y) {
			for (width x = 0; x < W; ++x) {
				rel(*this, sum(box_cell.slice(b*W*L + y*W + x, W*L, N)) <= 1);
			}
		}
	}
	\end{lstlisting}}
    
	\item Depending on their rotation, boxes occupy certain cells of the roll
	(constraint formalised in \ref{constr:box-rot-span}). For those cells $(x,y)$ within
	bounds for $b$-th box:

	\begin{itemize}
		\item For square boxes (constraint \ref{eq:span-cells:square-boxes}):
		{\NOINDENT \begin{lstlisting}
		for (length i = y; i <= y + b_length - 1; ++i) {
			for (width j = x; j <= x + b_width - 1; ++j) {
				rel(*this, (X(b,x,y) == 1) >> (C(b,j,i) == 1) );
			}
		}
		rel(*this, R(b) == 0);
		\end{lstlisting}}
		
		\item For rectangular boxes (constraints \ref{eq:span-cells:rectangular-boxes:0} and
		\ref{eq:span-cells:rectangular-boxes:1}):
		{\NOINDENT \begin{lstlisting}
		for (length i = y; i <= y + b_length - 1; ++i) {
			for (width j = x; j <= x + b_width - 1; ++j) {
				rel(*this, ((R(b) == 0) && (X(b,x,y) == 1)) >> (C(b,j,i) == 1) );
			}
		}
		\end{lstlisting}}
		{\NOINDENT \begin{lstlisting}
		for (length i = y; i <= y + b_width - 1; ++i) {
			for (width j = x; j <= x + b_length - 1; ++j) {
				rel(*this, ((R(b) == 1) && (X(b,x,y) == 1)) >> (C(b,j,i) == 1) );
			}
		}
		\end{lstlisting}}
	\end{itemize}
    
	\item Depending on their rotation, boxes cannot occupy certain cells of the
	roll (constraint formalised in \ref{constr:box-forbid}). For those cells $(x,y)$
	out of bounds for $b$-th box:
    
	\begin{itemize}
		\item For square boxes (constraint \ref{eq:forbid-span-cells:square-boxes}):
		{\NOINDENT \begin{lstlisting}
		rel(*this, X(b,x,y) == 0);
		\end{lstlisting}}
		
		\item For rectangular boxes (constraints \ref{eq:forbid-span-cells:rectangular-boxes:0}
		and \ref{eq:forbid-span-cells:rectangular-boxes:1}):
		{\NOINDENT \begin{lstlisting}
		rel(*this, (R(b) == 0) >> (X(b,x,y) == 0) );
		\end{lstlisting}}
		{\NOINDENT \begin{lstlisting}
		rel(*this, (R(b) == 1) >> (X(b,x,y) == 0) );
		\end{lstlisting}}
	\end{itemize}
    
\end{enumerate}

\subsection{Finding the optimum solution}
\label{sec:constraint-programming:optimum}

The constraints presented in the previous section only guarantee that if a
feasible solution exists then, eventually, it will be found. However, they
do not, and can not possibly guarantee, by definition, the optimality of the
solution. For this reason, in order to make Gecode look for an optimum solution,
we use the \textit{Branch \& Bound} solver that needs the implementation of
a function, \textit{constrain}, in which we can impose new constraints that
can help the solver find better solutions.

\begin{figure}[H]
	\centering
	{\NOINDENT \begin{lstlisting}[xleftmargin=.24\textwidth]
	virtual void constrain(const Space& _b);
	\end{lstlisting}}
	\centeredcaption{The header of the function \textit{constrain}}
	\label{fig:constrain-header}
\end{figure}

The function \textit{constrain} (see figure \ref{fig:constrain-header}) is
simple to understand: it receives a single parameter of type \textit{Space},
which can be cast to the same type as our solver, and contains the current
best solution. We can access its arrays of variables and their value(s)
and impose new constraints to force Gecode find better solutions.

\hfill

An easy approach to make Gecode find solutions that use shorter roll length is
to forbid placing any box on all those cells with length $\optlength$, where
$\optlength$ is the shortest length found so far. That is, for all those cells
$(x,y)$ such that $y \ge \optlength$, impose that they cannot contain a box.
This way the next solution found, if there is any, will have stricter shorter
length. In general, given a roll length $\optlength$, the new constraints imposed
are:

\begin{flalign}
\label{eq:optimal-solution}
\begin{split}
C_{b,x,y} = 0,
& \qquad \forall b,\; 1 \le b \le N \\
& \qquad \forall x,y,\; 1 \le x \le W, \optlength \le y \le L
\end{split}
\end{flalign}

The implementation of the constraints in \ref{eq:optimal-solution} in Gecode is done
with the following code:

{\NOINDENT \begin{lstlisting}
for (int b = 0; b < N; ++b) {
	for (length i = RL - 1; i < L; ++i) {
		for (width j = 0; j < W; ++j) {
			rel(*this, C(b,j,i) == 0);
		}
	}
}
\end{lstlisting}}

where $RL = \optlength$ can be calculated using the values assigned to the variables
in the \textit{Space} object passed as parameter to the function \textit{constrain}.

\subsubsection{Heuristics}
\label{sec:constraint-programming:optimum:heuristics}

When using the method described in section \ref{sec:constraint-programming:optimum}
and when given enough time, Gecode is ensured to eventually be able to find an
optimal solution: each solution found using that method will have strictly shorter
roll length than the previous. Therefore, eventually, Gecode will find a solution
with a series of constraints (limiting the roll length used) that will make the
instance infeasible. The solution found before that point is the optimal. However,
this only happens when ``given enough time'', that is, however efficient Gecode
might be it might take several hours. In order to tackle this issue, we
implemented a number of heuristics that should make Gecode stop as soon as possible.

\hfill

All the heuristics implemented are very simple. The variable and value selection
strategies are kept as simple as possible: for the variables, choose the first
unassigned, and for the values, the maximum in the domain of the variable chosen.
Since all the variables are Boolean, the value chosen is 1, interpreted as ``always
assign''. In Gecode, this is implemented as follows:

{\NOINDENT \begin{lstlisting}
branch(*this, box_rotated + box_corner, BOOL_VAR_NONE(), BOOL_VAL_MAX());
\end{lstlisting}}

Now, notice that in the implementation of the constraints of the generic model
in Gecode needs an array with the list of boxes from the input. The only thing
done as an attempt to speed up the solver's execution time is to rearrange
the boxes in this array so that the constraints are ordered in a particular way.
For example, we may want the solver to assign larger boxes first, and smaller boxes
last. Or simply select each boxes at random\footnote{ This could have been implemented
in the variable selection strategy. However, this way we avoid the solver computing
a maximum or minimum each time it has to select a variable.}.

\hfill

The order is not the only attempt at speeding up the code. Several strategies are
``concatenated'', that is, executed one after the other, in the following way:
after the solver has finished its execution with a particular ordering of the boxes
with a solution of roll length $\optlength_1$, execute the solver again with a
different ordering and, instead of using the upper bound on the maximum length
$L$ defined in equation \ref{eq:upper-bound-L}, use the minimum of the two (see
equation \ref{eq:upper-bound-L:better}) which means that the matrices for variables
\ref{var:box-cell} and \ref{var:box-corner} will become smaller with every step.
\begin{equation}
\label{eq:upper-bound-L:better}
L' = \min\{L, \optlength_1\}
\end{equation}

Algorithmically, this can be formalised in algorithm \ref{alg:constraint:programming:generic-heuristic}.

\hfill

\begin{algorithm}[H]
	\label{alg:constraint:programming:generic-heuristic}
	\DontPrintSemicolon
    
	\caption{Generic heuristic}
    
	$L := $ \textsc{UpperBoundRollLength}($\mathcal{B}$), using equation \ref{eq:upper-bound-L} \;
	$\mathcal{B}' :=$ sort boxes in $\mathcal{B}$ increasingly by area \;
	$S_1 := \textsc{Solve}(\mathcal{B}', L - 1)$ \;
	\;
	$L := \min\{ \text{length}(S_1), L \}$ \;
	$\mathcal{B}' :=$ sort boxes in $\mathcal{B}$ decreasingly by area \;
	$S_2 := \textsc{Solve}(\mathcal{B}', L - 1)$ \;
	\;
	$\cdots$ \;
	\;
	$L := \min\{ \text{length}(S_{n-1}), L \}$ \;
	$\mathcal{B}' :=$ sort boxes in $\mathcal{B}$ using some other criteria \;
	$S_n := \textsc{Solve}(\mathcal{B}', L - 1)$ \;
	\Return $S_n$
\end{algorithm}

\hfill

where $\text{length}(S_i)$ is the roll's length used in solution $S_i$, and $n$ is
the limit on the amount of heuristics concatenated. Needless to say that, if $S_i$
is an optimal solution then the solver should not take much time in concluding that
it can not possibly find a solution at step $i+1$. Each call to \textsc{Solve}
executes the solver once.

\hfill

Several heuristics were studied:
\begin{enumerate}
	\item Sort increasingly by area $+$ increasingly by width.
	\item Sort decreasingly by area $+$ decreasingly by width.
	\item Random permutation: scramble randomly the contents of $\mathcal{B}$
	and find a solution for it. This step is concatenated several times.
	\item Mixed heuristic: concatenate all the previous heuristics in the order
	they are listed.
\end{enumerate}

The mixed heuristic proved to be the best in practice.

\subsection{Compilation and execution}
\label{sec:constraint-programming:compilation-execution}

In order to compile this part of the project, while assuming that we are at the
root directory of the project, one should issue the following commands:
\begin{lstlisting}[language=bash]
~/box-wrapping$ cd CP/build-rules
~/box-wrapping/CP/build-rules$ make -f Makefile release
~/box-wrapping/CP/build-rules$ cd ..
~/box-wrapping/CP$ cd build-release
\end{lstlisting}

Once the compilation has finished we can execute the binary file generated\footnote{ There
is no need to create the directory \textit{build-release/} prior to compiling.}. The
complete usage can be seen by issuing the command:
\begin{lstlisting}[language=bash]
$ ./wrapping-boxes --help
\end{lstlisting}

Here are a few of the options explained:
\begin{itemize}
	\item If one wants to find $n$ solutions to a certain input, and store the
	best found in a certain file, issue the following command:
\begin{lstlisting}[language=bash]
$ ./wrapping-boxes -i $INPUT_FILE -o $OUTPUT_FILE --stop-at n --enumerate --rotate
\end{lstlisting}
	
	Storing the best solution is indicated by specifying an output file with ``-o''.
	The option ``enumerate'' will print on standard output all $n$ solutions found.
	The solver used is ``rotate'', which will not try to find an optimal solution.
	The ``stop-at'' option indicates the solver to stop when $n$ solutions are
	found.
	
	\item If one wants to find the best solution to an instance, use the ``optim'' solver
	instead of the solver ``rotate''.
\begin{lstlisting}[language=bash]
$ ./wrapping-boxes -i $INPUT_FILE -o $OUTPUT_FILE --stop-when 10.0 --enumerate --optim
\end{lstlisting}
	
	The option ``enumerate'' will make the program list all solutions found from
	the first (and probably worst) solution to the optimal (or quasi-optimal) one.
	With the option ``stop-when'' the solver will stop finding solutions after 10 seconds.
\end{itemize}

There are more options one could use: indicate the number of threads that the solver
can use, scramble (permute randomly) the input data and seed the random number generator
so that the permutation is different at every execution. It is important to say that
the option ``stop-at'' should always be specified, otherwise the solver will try to
find all feasible solutions within the matrix defined for variables \ref{var:box-cell}
(what cells does a box occupy) and \ref{var:box-corner} (where is a box's corner placed at).

\hfill

In order to use a heuristic, use the option ``heuris-*'', where '*' is either: ``incr'',
``decr'', ``rand'', or ``mix'', each of these being an alias for the heuristics
described in section \ref{sec:constraint-programming:optimum:heuristics}, in the same
order of appearance. These also have options of their own, like indicating how many
times the solver should be executed with the input data randomly permuted (the other
strategies are used only once).

